<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Forum Diskusi</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Cloudinary Widget -->
  <script src="https://upload-widget.cloudinary.com/global/all.js" type="text/javascript"></script>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #9999ff;
      --secondary: #7a7ae6;
    }
    
    body {
      font-family: 'Baloo 2', cursive;
      background-color: #f8fafc;
    }
    
    .app-container {
      max-width: 414px;
      margin: 0 auto;
      background: white;
      min-height: 100vh;
      position: relative;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
    
    .bottom-nav {
      position: fixed;
      bottom: 0;
      width: 100%;
      max-width: 414px;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
      background: white;
      z-index: 10;
      height: 70px;
      display: flex;
      align-items: center;
    }
    
    .nav-icon {
      transition: all 0.3s ease;
      font-size: 1.25rem;
    }
    
    .nav-icon.active {
      transform: translateY(-5px);
      color: var(--primary);
    }
    
    .app-logo {
      display: flex;
      align-items: center;
    }
    
    .app-logo-icon {
      background: linear-gradient(135deg, #9999ff, #7a7ae6);
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
    }
    
    .app-name {
      font-weight: 700;
      font-size: 1.25rem;
      color: #9999ff;
    }

    /* Thread styles - IMPROVED FOR MOBILE */
    .thread-card { 
      transition: all 0.2s ease; 
      padding: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .thread-card:hover { box-shadow: 0 4px 6px -1px rgba(0,0,0,.1), 0 2px 4px -1px rgba(0,0,0,.06); }
    .like-btn:hover { color: #e53e3e; }
    .reply-btn:hover { color: #3182ce; }
    .avatar { 
      width: 36px; 
      height: 36px; 
      border-radius: 50%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: bold; 
      color: white; 
      flex-shrink: 0;
    }
    .small-btn { font-size: 0.85rem; padding: .25rem .5rem; border-radius: .5rem; }
    
    /* Image styles */
    .thread-image {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      margin-top: 10px;
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    
    .thread-image:hover {
      transform: scale(1.02);
    }
    
    .image-preview-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    
    .image-preview {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .image-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .remove-image-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(255, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .image-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .image-modal.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    .image-modal img {
      max-width: 90%;
      max-height: 90%;
      border-radius: 8px;
    }
    
    .close-modal-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Improved mobile responsiveness */
    .thread-content {
      font-size: 0.9375rem;
      line-height: 1.4;
    }
    
    .thread-meta {
      font-size: 0.75rem;
    }
    
    .action-buttons {
      display: flex;
      gap: 1rem;
      margin-top: 0.75rem;
    }
    
    .action-btn {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.8125rem;
      padding: 0.25rem 0.5rem;
    }
    
    .reply-input-container {
      display: flex;
      gap: 0.25rem;
      margin-top: 0.75rem;
      align-items: center;
    }
    
    .reply-input {
      flex: 1;
      font-size: 0.875rem;
      padding: 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #e2e8f0;
    }
    
    .send-reply-btn {
      background: #9999ff;
      color: white;
      border: none;
      border-radius: 0.5rem;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .send-reply-btn:hover {
      background: #7a7ae6;
    }
    
    .send-reply-btn:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
    }
    
    /* FAB Styles */
    .fab-container {
      position: fixed;
      bottom: 80px;
      right: 24px;
      z-index: 1000;
      transition: all 0.3s ease;
    }
    
    .fab {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background-color: #9999ff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .fab:hover {
      background-color: #7a7ae6;
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .fab i {
      font-size: 1.5rem;
    }
    
    .fab-form-container {
      position: fixed;
      bottom: 146px;
      right: 24px;
      width: 300px;
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      padding: 16px;
      z-index: 999;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .fab-form-container.active {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    .fab-form-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 998;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .fab-form-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Sidebar Styles */
    .sidebar {
      position: fixed;
      top: 0;
      right: -300px;
      width: 300px;
      height: 100vh;
      background-color: white;
      box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
      transition: right 0.3s ease;
      z-index: 1001;
      overflow-y: auto;
    }
    
    .sidebar.active {
      right: 0;
    }
    
    .sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .hamburger {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #9999ff;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .hamburger:hover {
      background-color: #7a7ae6;
      transform: scale(1.05);
    }
    
    .sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .sidebar-title {
      font-size: 1.25rem;
      font-weight: 700;
      color: #9999ff;
    }
    
    .sidebar-content {
      padding: 1rem;
    }
    
    .ai-feature {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      background-color: #f7f9fc;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .ai-feature:hover {
      background-color: #e6f0ff;
      transform: translateY(-2px);
    }
    
    .ai-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #9999ff;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      margin-right: 1rem;
    }
    
    .ai-text {
      flex: 1;
    }
    
    .ai-title {
      font-weight: 600;
      color: #2d3748;
    }
    
    .ai-desc {
      font-size: 0.875rem;
      color: #718096;
    }
    
    /* Pagination Styles */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      gap: 0.5rem;
    }
    
    .pagination-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f1f5f9;
      color: #475569;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .pagination-btn:hover:not(:disabled) {
      background-color: #e2e8f0;
    }
    
    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .pagination-btn.active {
      background-color: #9999ff;
      color: white;
    }
    
    .pagination-info {
      font-size: 0.875rem;
      color: #64748b;
      margin: 0 0.5rem;
    }
    
    .loading-indicator {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      color: #64748b;
    }
    
    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #e2e8f0;
      border-top: 2px solid #9999ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Style khusus untuk bottom nav items */
    .nav-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6b7280;
      text-decoration: none;
      flex: 1;
      height: 100%;
      padding: 0.5rem 0;
    }
    
    .nav-item span {
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    
    /* Styles for collapsible comments */
    .comments-section {
      transition: all 0.3s ease;
      overflow: hidden;
      max-height: 1000px;
    }
    
    .comments-section.collapsed {
      max-height: 0;
      opacity: 0;
      margin: 0;
      padding: 0;
    }
    
    .comments-toggle-btn {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      color: #6b7280;
      background: none;
      border: none;
      padding: 0.25rem 0.5rem;
      font-size: 0.8125rem;
      cursor: pointer;
      margin-top: 0.5rem;
      border-radius: 0.25rem;
      transition: all 0.2s ease;
    }
    
    .comments-toggle-btn:hover {
      color: #9999ff;
      background-color: #f3f4f6;
    }
    
    .toggle-icon {
      transition: transform 0.3s ease;
      font-size: 0.75rem;
    }
    
    .toggle-icon.collapsed {
      transform: rotate(-90deg);
    }
    
    .comments-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e5e7eb;
    }
    
    .comments-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: #374151;
    }
    
    .reply-item {
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Improved mobile styles */
    @media (max-width: 414px) {
      .thread-card {
        padding: 0.875rem;
        margin-bottom: 0.875rem;
      }
      
      .thread-content {
        font-size: 0.9375rem;
      }
      
      .action-btn {
        font-size: 0.8125rem;
        padding: 0.375rem 0.5rem;
      }
      
      .reply-input {
        font-size: 0.875rem;
        padding: 0.5rem;
      }
      
      .fab-form-container {
        width: 85%;
        right: 50%;
        transform: translate(50%, 20px);
      }
      
      .fab-form-container.active {
        transform: translate(50%, 0);
      }
      
      .sidebar {
        width: 280px;
        right: -280px;
      }
      
      .pagination {
        padding: 0.75rem;
      }
      
      .pagination-btn {
        width: 32px;
        height: 32px;
      }
      
      .bottom-nav {
        height: 65px;
      }
      
      .nav-icon {
        font-size: 1.1rem;
      }
      
      .thread-image {
        max-height: 200px;
      }
      
      .image-preview {
        width: 60px;
        height: 60px;
      }
      
      .send-reply-btn {
        width: 32px;
        height: 32px;
      }
    }
  </style>
</head>
<body class="bg-gray-50">

  <!-- Mobile App Container -->
  <div class="app-container">
    <!-- App Header -->
    <header class="bg-gradient-to-r from-primary to-secondary p-4 text-white">
      <div class="flex justify-between items-center">
        <div class="app-logo">
          <div class="app-logo-icon" style="background: #9999ff; color: white;">
            <i class="fas fa-atom"></i>
          </div>
          <h1 class="app-name" style="color: #9999ff;">QUANTARA</h1>
        </div>
        <div class="flex items-center space-x-3">
          <i class="fas fa-search"></i>
          <div class="hamburger" id="hamburgerButton">
            <i class="fas fa-bars"></i>
          </div>
        </div>
      </div>
    </header>

    <!-- Sidebar -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title">Menu AI</div>
        <button class="hamburger" id="closeSidebar">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div class="sidebar-content">
        <!-- Link ke pesan.html -->
        <a href="../pesan/pesan.html" class="ai-feature">
          <div class="ai-icon">
            <i class="fas fa-paper-plane"></i>
          </div>
          <div class="ai-text">
            <div class="ai-title">Message</div>
            <div class="ai-desc">Sapa Teman dengan pesan singkat</div>
          </div>
        </a>
        
        <!-- Link ke nayra.html -->
        <a href="../ai/nayra.html" class="ai-feature">
          <div class="ai-icon">
            <i class="fas fa-robot"></i>
          </div>
          <div class="ai-text">
            <div class="ai-title">Nayra AI</div>
            <div class="ai-desc">Asisten AI untuk membantu belajar sains</div>
          </div>
        </a>
      </div>
    </div>
    
    <!-- Image Modal -->
    <div class="image-modal" id="imageModal">
      <button class="close-modal-btn" id="closeModalBtn">
        <i class="fas fa-times"></i>
      </button>
      <img id="modalImage" src="" alt="Gambar diperbesar">
    </div>
    
    <!-- Thread Container -->
    <main class="pb-20">
      <div id="threads" class="p-3 space-y-3"></div>
      <div id="loadingIndicator" class="loading-indicator" style="display: none;">
        <div class="loading-spinner"></div>
        <span>Memuat thread...</span>
      </div>
      <div id="pagination" class="pagination"></div>
    </main>

    <!-- Post Form (Hidden by default, will be shown via FAB) -->
    <div class="fab-form-overlay" id="fabFormOverlay"></div>
    
    <div class="fab-form-container" id="fabFormContainer">
      <div class="flex items-start space-x-3 mb-4">
        <div class="avatar" style="background-color: #9999ff;">
          <span id="userInitial" class="text-lg">U</span>
        </div>
        <div>
          <p class="text-sm font-semibold" id="fabUserName">User</p>
        </div>
      </div>
      
      <textarea 
        id="fabMsgInput" 
        placeholder="Apa yang ingin Anda diskusikan? (bisa LaTeX: $x^2+y^2=z^2$)" 
        rows="4"
        class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-9999ff focus:border-transparent resize-none"
        style="--tw-ring-color: #9999ff;"
      ></textarea>
      
      <!-- Image preview container -->
      <div id="imagePreviewContainer" class="image-preview-container" style="display: none;"></div>
      
      <div class="flex justify-between items-center mt-3">
        <div class="flex space-x-2" style="color: #9999ff;">
          <!-- Image upload button -->
          <button id="imageUploadBtn" class="p-2 rounded-full hover:bg-blue-50" title="Unggah gambar">
            <i class="fas fa-image"></i>
          </button>
          <button class="p-2 rounded-full hover:bg-blue-50"><i class="fas fa-code"></i></button>
        </div>
        <button id="fabSendBtn" class="text-white px-4 py-2 rounded-full font-medium disabled:opacity-50 disabled:cursor-not-allowed" 
                style="background-color: #9999ff; hover:background-color: #7a7ae6;" disabled>
          Post
        </button>
      </div>
    </div>

    <!-- FAB Button -->
    <div class="fab-container">
      <div class="fab" id="fabButton">
        <i class="fas fa-plus"></i>
      </div>
    </div>
    
    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
      <a href="../dashboard siswa.html" class="nav-item">
        <i class="fas fa-home nav-icon"></i>
        <span>Beranda</span>
      </a>
      <a href="../soal harian/dashboard soal.html" class="nav-item">
        <i class="fas fa-flask nav-icon"></i>
        <span>Soal Harian</span>
      </a>
      <a href="../ai/nayra.html" class="nav-item">
        <i class="fas fa-robot nav-icon"></i>
        <span>Nayra AI</span>
      </a>
      <a href="kategori/kategori materi.html" class="nav-item">
        <i class="fas fa-chalkboard-teacher nav-icon"></i>
        <span>Materi Harian</span>
      </a>
      <a href="profil.html" class="nav-item">
        <i class="fas fa-user nav-icon"></i>
        <span>Profil</span>
      </a>
    </nav>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import {
      getFirestore, collection, addDoc, serverTimestamp,
      query, orderBy, onSnapshot, doc, updateDoc,
      arrayUnion, arrayRemove, getDoc,
      deleteDoc, getDocs, writeBatch, limit, startAfter
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // ðŸ”¹ Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyAJ5I8k2MzAyDLt9fUcXHRNtRVjKB_ETLY",
      authDomain: "projectid-81104.firebaseapp.com",
      projectId: "projectid-81104",
      storageBucket: "projectid-81104.appspot.com",
      messagingSenderId: "554913260457",
      appId: "1:554913260457:web:bf988867ebfd902c651ab8"
    };

    // ðŸ”¹ Cloudinary Configuration
    const CLOUDINARY_CLOUD_NAME = "ddjzsvomj";
    const CLOUDINARY_API_KEY = "846512428512365";
    const CLOUDINARY_UPLOAD_PRESET = "forum_images"; // Anda perlu membuat upload preset di Cloudinary

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const threadsDiv = document.getElementById("threads");
    const userInitial = document.getElementById("userInitial");
    const fabUserName = document.getElementById("fabUserName");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const paginationDiv = document.getElementById("pagination");
    
    // FAB elements
    const fabButton = document.getElementById("fabButton");
    const fabFormContainer = document.getElementById("fabFormContainer");
    const fabFormOverlay = document.getElementById("fabFormOverlay");
    const fabMsgInput = document.getElementById("fabMsgInput");
    const fabSendBtn = document.getElementById("fabSendBtn");
    const imageUploadBtn = document.getElementById("imageUploadBtn");
    const imagePreviewContainer = document.getElementById("imagePreviewContainer");
    
    // Sidebar elements
    const hamburgerButton = document.getElementById("hamburgerButton");
    const closeSidebar = document.getElementById("closeSidebar");
    const sidebar = document.getElementById("sidebar");
    const sidebarOverlay = document.getElementById("sidebarOverlay");
    
    // Image modal elements
    const imageModal = document.getElementById("imageModal");
    const modalImage = document.getElementById("modalImage");
    const closeModalBtn = document.getElementById("closeModalBtn");

    // Pagination variables
    const THREADS_PER_PAGE = 5;
    let currentPage = 1;
    let lastVisible = null;
    let firstVisible = null;
    let totalThreads = 0;
    let totalPages = 1;
    let threadsQuery = null;
    let threadsUnsubscribe = null;

    let currentUser = null;
    let currentProfile = null;
    let uploadedImages = []; // Array untuk menyimpan URL gambar yang diunggah
    
    // IndexedDB variables
    let dbCache = null;
    const DB_NAME = 'forum_cache';
    const DB_VERSION = 1;
    const THREADS_STORE = 'threads';
    const REPLIES_STORE = 'replies';
    const CACHE_DURATION = 5 * 60 * 1000; // 5 menit dalam milidetik

    // Initialize IndexedDB
    async function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          dbCache = request.result;
          resolve(dbCache);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          
          // Buat store untuk threads
          if (!db.objectStoreNames.contains(THREADS_STORE)) {
            const threadsStore = db.createObjectStore(THREADS_STORE, { keyPath: 'id' });
            threadsStore.createIndex('createdAt', 'createdAt', { unique: false });
            threadsStore.createIndex('cachedAt', 'cachedAt', { unique: false });
          }
          
          // Buat store untuk replies
          if (!db.objectStoreNames.contains(REPLIES_STORE)) {
            const repliesStore = db.createObjectStore(REPLIES_STORE, { keyPath: 'id' });
            repliesStore.createIndex('threadId', 'threadId', { unique: false });
            repliesStore.createIndex('createdAt', 'createdAt', { unique: false });
            repliesStore.createIndex('cachedAt', 'cachedAt', { unique: false });
          }
        };
      });
    }

    // Save threads to cache
    async function saveThreadsToCache(threads) {
      if (!dbCache) return;
      
      return new Promise((resolve, reject) => {
        const transaction = dbCache.transaction([THREADS_STORE], 'readwrite');
        const store = transaction.objectStore(THREADS_STORE);
        
        threads.forEach(thread => {
          store.put({
            ...thread,
            cachedAt: Date.now()
          });
        });
        
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
    }

    // Get threads from cache
    async function getThreadsFromCache(page = 1, limit = THREADS_PER_PAGE) {
      if (!dbCache) return { threads: [], total: 0 };
      
      return new Promise((resolve, reject) => {
        const transaction = dbCache.transaction([THREADS_STORE], 'readonly');
        const store = transaction.objectStore(THREADS_STORE);
        const index = store.index('createdAt');
        const request = index.getAll();
        
        request.onsuccess = () => {
          const allThreads = request.result;
          
          // Filter out expired cache
          const now = Date.now();
          const validThreads = allThreads.filter(thread => 
            thread.cachedAt && (now - thread.cachedAt) < CACHE_DURATION
          );
          
          // Sort by createdAt descending
          validThreads.sort((a, b) => b.createdAt - a.createdAt);
          
          // Apply pagination
          const start = (page - 1) * limit;
          const end = start + limit;
          const paginatedThreads = validThreads.slice(start, end);
          
          resolve({
            threads: paginatedThreads,
            total: validThreads.length
          });
        };
        
        request.onerror = () => reject(request.error);
      });
    }

    // Save replies to cache
    async function saveRepliesToCache(threadId, replies) {
      if (!dbCache) return;
      
      return new Promise((resolve, reject) => {
        const transaction = dbCache.transaction([REPLIES_STORE], 'readwrite');
        const store = transaction.objectStore(REPLIES_STORE);
        
        replies.forEach(reply => {
          store.put({
            ...reply,
            threadId: threadId,
            cachedAt: Date.now()
          });
        });
        
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => reject(transaction.error);
      });
    }

    // Get replies from cache
    async function getRepliesFromCache(threadId) {
      if (!dbCache) return [];
      
      return new Promise((resolve, reject) => {
        const transaction = dbCache.transaction([REPLIES_STORE], 'readonly');
        const store = transaction.objectStore(REPLIES_STORE);
        const index = store.index('threadId');
        const request = index.getAll(threadId);
        
        request.onsuccess = () => {
          const allReplies = request.result;
          
          // Filter out expired cache
          const now = Date.now();
          const validReplies = allReplies.filter(reply => 
            reply.cachedAt && (now - reply.cachedAt) < CACHE_DURATION
          );
          
          // Sort by createdAt ascending
          validReplies.sort((a, b) => a.createdAt - b.createdAt);
          
          resolve(validReplies);
        };
        
        request.onerror = () => reject(request.error);
      });
    }

    // Clear expired cache
    async function clearExpiredCache() {
      if (!dbCache) return;
      
      const now = Date.now();
      
      // Clear expired threads
      const threadsTransaction = dbCache.transaction([THREADS_STORE], 'readwrite');
      const threadsStore = threadsTransaction.objectStore(THREADS_STORE);
      const threadsRequest = threadsStore.index('cachedAt').openCursor();
      
      threadsRequest.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          if (now - cursor.value.cachedAt > CACHE_DURATION) {
            cursor.delete();
          }
          cursor.continue();
        }
      };
      
      // Clear expired replies
      const repliesTransaction = dbCache.transaction([REPLIES_STORE], 'readwrite');
      const repliesStore = repliesTransaction.objectStore(REPLIES_STORE);
      const repliesRequest = repliesStore.index('cachedAt').openCursor();
      
      repliesRequest.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          if (now - cursor.value.cachedAt > CACHE_DURATION) {
            cursor.delete();
          }
          cursor.continue();
        }
      };
    }

    // Toggle sidebar
    function toggleSidebar() {
      sidebar.classList.toggle("active");
      sidebarOverlay.classList.toggle("active");
    }

    // Close sidebar
    function closeSidebarFunc() {
      sidebar.classList.remove("active");
      sidebarOverlay.classList.remove("active");
    }

    // Event listeners for sidebar
    hamburgerButton.addEventListener("click", toggleSidebar);
    closeSidebar.addEventListener("click", closeSidebarFunc);
    sidebarOverlay.addEventListener("click", closeSidebarFunc);

    // Toggle image modal
    function openImageModal(imageUrl) {
      modalImage.src = imageUrl;
      imageModal.classList.add("active");
    }

    function closeImageModal() {
      imageModal.classList.remove("active");
      modalImage.src = "";
    }

    // Event listeners for image modal
    closeModalBtn.addEventListener("click", closeImageModal);
    imageModal.addEventListener("click", (e) => {
      if (e.target === imageModal) {
        closeImageModal();
      }
    });

    // Toggle FAB form
    function toggleFabForm() {
      fabFormContainer.classList.toggle("active");
      fabFormOverlay.classList.toggle("active");
      
      if (fabFormContainer.classList.contains("active")) {
        fabMsgInput.focus();
      }
    }

    // Close FAB form
    function closeFabForm() {
      fabFormContainer.classList.remove("active");
      fabFormOverlay.classList.remove("active");
      fabMsgInput.value = "";
      fabSendBtn.disabled = true;
      // Clear image previews
      clearImagePreviews();
    }

    // Clear image previews
    function clearImagePreviews() {
      uploadedImages = [];
      imagePreviewContainer.innerHTML = "";
      imagePreviewContainer.style.display = "none";
    }

    // Event listeners for FAB
    fabButton.addEventListener("click", toggleFabForm);
    fabFormOverlay.addEventListener("click", closeFabForm);

    // Aktifkan tombol hanya kalau ada teks atau gambar
    fabMsgInput.addEventListener('input', () => {
      const hasText = fabMsgInput.value.trim().length > 0;
      const hasImages = uploadedImages.length > 0;
      fabSendBtn.disabled = !(hasText || hasImages);
    });

    // Initialize Cloudinary Upload Widget
    function initializeCloudinaryWidget() {
      const myWidget = cloudinary.createUploadWidget(
        {
          cloudName: CLOUDINARY_CLOUD_NAME,
          uploadPreset: CLOUDINARY_UPLOAD_PRESET,
          sources: ['local', 'url', 'camera'],
          multiple: true,
          maxFiles: 5,
          clientAllowedFormats: ['jpg', 'jpeg', 'png', 'gif', 'webp'],
          maxFileSize: 5000000, // 5MB
          styles: {
            palette: {
              window: "#FFFFFF",
              windowBorder: "#90A0B3",
              tabIcon: "#9999ff",
              menuIcons: "#5A616A",
              textDark: "#000000",
              textLight: "#FFFFFF",
              link: "#9999ff",
              action: "#FF620C",
              inactiveTabIcon: "#0E2F5A",
              error: "#F44235",
              inProgress: "#9999ff",
              complete: "#20B832",
              sourceBg: "#E4EBF1"
            }
          }
        },
        (error, result) => {
          if (!error && result && result.event === "success") {
            console.log("Image uploaded successfully: ", result.info);
            
            // Add image URL to uploadedImages array
            uploadedImages.push({
              url: result.info.secure_url,
              public_id: result.info.public_id
            });
            
            // Update image preview
            updateImagePreviews();
            
            // Enable send button if there are images
            fabSendBtn.disabled = false;
          }
          
          if (error) {
            console.error("Cloudinary upload error:", error);
            alert("Gagal mengunggah gambar: " + error.message);
          }
        }
      );

      // Add event listener to image upload button
      imageUploadBtn.addEventListener("click", () => {
        myWidget.open();
      }, false);
    }

    // Update image previews in the form
    function updateImagePreviews() {
      imagePreviewContainer.innerHTML = "";
      
      uploadedImages.forEach((image, index) => {
        const previewDiv = document.createElement("div");
        previewDiv.className = "image-preview";
        
        previewDiv.innerHTML = `
          <img src="${image.url}" alt="Preview ${index + 1}">
          <button class="remove-image-btn" data-index="${index}">
            <i class="fas fa-times"></i>
          </button>
        `;
        
        imagePreviewContainer.appendChild(previewDiv);
        
        // Add click event to image
        const img = previewDiv.querySelector('img');
        img.addEventListener('click', () => {
          openImageModal(image.url);
        });
      });
      
      // Show container if there are images
      imagePreviewContainer.style.display = uploadedImages.length > 0 ? "flex" : "none";
      
      // Add event listeners to remove buttons
      document.querySelectorAll('.remove-image-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const index = parseInt(btn.getAttribute('data-index'));
          removeImage(index);
        });
      });
    }

    // Remove image from preview
    function removeImage(index) {
      uploadedImages.splice(index, 1);
      updateImagePreviews();
      
      // Disable send button if no text and no images
      const hasText = fabMsgInput.value.trim().length > 0;
      const hasImages = uploadedImages.length > 0;
      fabSendBtn.disabled = !(hasText || hasImages);
    }

    // Ambil profil user (dari collection users -> field name)
    async function getUserProfile(uid) {
      try {
        const userRef = doc(db, "users", uid);
        const snap = await getDoc(userRef);
        return snap.exists() ? snap.data() : null;
      } catch (err) {
        console.error("getUserProfile:", err);
        return null;
      }
    }

    // Cek login
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "index.html";
      } else {
        currentUser = user;
        currentProfile = await getUserProfile(user.uid);
        const initial = (currentProfile?.name?.charAt(0) || user.email.charAt(0)).toUpperCase();
        userInitial.textContent = initial;
        fabUserName.textContent = currentProfile?.name || user.email;
        
        // Initialize IndexedDB
        await initIndexedDB();
        // Clear expired cache
        await clearExpiredCache();
        
        // Initialize Cloudinary widget after user is authenticated
        initializeCloudinaryWidget();
        await loadThreads();
      }
    });

    // Post thread baru dari FAB form
    fabSendBtn.addEventListener("click", async () => {
      const text = fabMsgInput.value.trim();
      if (!text && uploadedImages.length === 0) return;
      
      try {
        // Prepare thread data
        const threadData = {
          uid: currentUser.uid,
          email: currentUser.email,
          name: currentProfile?.name || currentUser.email,
          teks: text,
          likes: 0,
          likedBy: [],
          createdAt: serverTimestamp()
        };
        
        // Add images if any
        if (uploadedImages.length > 0) {
          threadData.images = uploadedImages;
        }
        
        await addDoc(collection(db, "threads"), threadData);
        
        // Reset form
        closeFabForm();
        clearImagePreviews();
        
        // Reset to first page after posting
        currentPage = 1;
        await loadThreads();
      } catch (err) {
        console.error("add thread error:", err);
        alert("Gagal membuat thread: " + err.message);
      }
    });

    // Enter key untuk post dari FAB form
    fabMsgInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.ctrlKey) {
        e.preventDefault();
        fabSendBtn.click();
      }
    });

    // Hitung total jumlah thread untuk pagination
    async function getTotalThreads() {
      try {
        const threadsSnapshot = await getDocs(collection(db, "threads"));
        return threadsSnapshot.size;
      } catch (err) {
        console.error("Error getting total threads:", err);
        return 0;
      }
    }

    // Load threads dengan pagination (with cache)
    async function loadThreads() {
      try {
        loadingIndicator.style.display = "flex";
        threadsDiv.innerHTML = "";
        
        // Unsubscribe previous listener if exists
        if (threadsUnsubscribe) {
          threadsUnsubscribe();
        }
        
        // Try to get threads from cache first
        const cacheResult = await getThreadsFromCache(currentPage, THREADS_PER_PAGE);
        
        if (cacheResult.threads.length > 0) {
          // Render threads from cache
          cacheResult.threads.forEach((thread) => {
            renderThread(thread.id, thread);
          });
          
          totalThreads = cacheResult.total;
          totalPages = Math.ceil(totalThreads / THREADS_PER_PAGE);
          renderPagination();
          
          // Render LaTeX
          renderMathInElement(threadsDiv, {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
            ]
          });
          
          loadingIndicator.style.display = "none";
          console.log('Loaded threads from cache');
        } else {
          // If no cache, get from Firebase
          console.log('No cache available, loading from Firebase');
        }
        
        // Get total threads count
        totalThreads = await getTotalThreads();
        totalPages = Math.ceil(totalThreads / THREADS_PER_PAGE);
        
        // Build query based on current page
        if (currentPage === 1) {
          threadsQuery = query(
            collection(db, "threads"), 
            orderBy("createdAt", "desc"), 
            limit(THREADS_PER_PAGE)
          );
        } else {
          // We need to get the last document from previous page
          const firstPageQuery = query(
            collection(db, "threads"),
            orderBy("createdAt", "desc"),
            limit((currentPage - 1) * THREADS_PER_PAGE)
          );
          
          const firstPageSnapshot = await getDocs(firstPageQuery);
          const lastDoc = firstPageSnapshot.docs[firstPageSnapshot.docs.length - 1];
          
          threadsQuery = query(
            collection(db, "threads"),
            orderBy("createdAt", "desc"),
            startAfter(lastDoc),
            limit(THREADS_PER_PAGE)
          );
        }
        
        // Set up real-time listener for current page
        threadsUnsubscribe = onSnapshot(threadsQuery, async (snapshot) => {
          threadsDiv.innerHTML = "";
          const threadsToCache = [];
          
          snapshot.forEach((docSnap) => {
            const threadData = docSnap.data();
            // Convert timestamp for caching
            const threadForCache = {
              id: docSnap.id,
              ...threadData,
              createdAt: threadData.createdAt?.toDate?.()?.getTime() || Date.now()
            };
            threadsToCache.push(threadForCache);
            renderThread(docSnap.id, threadData);
          });
          
          // Save to cache
          if (threadsToCache.length > 0) {
            await saveThreadsToCache(threadsToCache);
          }
          
          // Update pagination UI
          renderPagination();
          
          // render LaTeX
          renderMathInElement(threadsDiv, {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
            ]
          });
          
          loadingIndicator.style.display = "none";
        }, (err) => {
          console.error("thread snapshot error:", err);
          loadingIndicator.style.display = "none";
        });
      } catch (err) {
        console.error("Error loading threads:", err);
        loadingIndicator.style.display = "none";
      }
    }

    // Render pagination controls
    function renderPagination() {
      if (totalPages <= 1) {
        paginationDiv.innerHTML = "";
        return;
      }
      
      let paginationHTML = "";
      
      // Previous button
      paginationHTML += `
        <button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">
          <i class="fas fa-chevron-left"></i>
        </button>
      `;
      
      // Page numbers
      const maxVisiblePages = 5;
      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      
      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }
      
      if (startPage > 1) {
        paginationHTML += `
          <button class="pagination-btn" onclick="changePage(1)">1</button>
          ${startPage > 2 ? '<span class="pagination-info">...</span>' : ''}
        `;
      }
      
      for (let i = startPage; i <= endPage; i++) {
        paginationHTML += `
          <button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">
            ${i}
          </button>
        `;
      }
      
      if (endPage < totalPages) {
        paginationHTML += `
          ${endPage < totalPages - 1 ? '<span class="pagination-info">...</span>' : ''}
          <button class="pagination-btn" onclick="changePage(${totalPages})">${totalPages}</button>
        `;
      }
      
      // Next button
      paginationHTML += `
        <button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">
          <i class="fas fa-chevron-right"></i>
        </button>
      `;
      
      // Page info
      paginationHTML += `
        <span class="pagination-info">
          Halaman ${currentPage} dari ${totalPages}
        </span>
      `;
      
      paginationDiv.innerHTML = paginationHTML;
    }

    // Change page function
    window.changePage = async function(page) {
      if (page < 1 || page > totalPages || page === currentPage) return;
      
      currentPage = page;
      await loadThreads();
      
      // Scroll to top of threads
      threadsDiv.scrollIntoView({ behavior: 'smooth' });
    };

    // Render Thread (dengan tombol delete bila pemilik)
    function renderThread(id, data) {
      const div = document.createElement("div");
      div.className = "thread-card bg-white rounded-lg border border-gray-200";

      const colors = ['#9999ff','#ff9999','#99ff99','#ff99ff','#ffcc99','#ffff99'];
      const colorIndex = Math.abs(hashCode(data.name || data.email || "")) % colors.length;
      const avatarColor = colors[colorIndex];
      const initial = (data.name || data.email || "").charAt(0).toUpperCase();
      const isLiked = data.likedBy && data.likedBy.includes(currentUser.uid);
      const likeCount = data.likes || 0;

      // show delete button if current user is owner
      const deleteThreadBtn = (data.uid === currentUser.uid)
        ? `<button onclick="deleteThread('${id}')" title="Hapus thread" class="ml-2 text-red-500 hover:text-red-700 text-sm"><i class="fas fa-trash"></i></button>`
        : "";

      // Prepare images HTML
      let imagesHTML = "";
      if (data.images && data.images.length > 0) {
        imagesHTML = `<div class="mt-3">`;
        data.images.forEach((img, idx) => {
          imagesHTML += `
            <img src="${img.url}" alt="Gambar ${idx + 1}" class="thread-image" onclick="openImageModal('${img.url}')">
          `;
        });
        imagesHTML += `</div>`;
      }

      div.innerHTML = `
        <div class="flex items-start gap-3">
          <div class="avatar" style="background-color: ${avatarColor};"><span>${initial}</span></div>
          <div class="flex-1 min-w-0">
            <div class="flex items-center gap-2 thread-meta">
              <p class="font-semibold text-gray-900 truncate">${escapeHtml(data.name || data.email)}</p>
              <span class="text-gray-500">â€¢</span>
              <p class="text-gray-500 whitespace-nowrap">${formatDate(data.createdAt?.toDate?.())}</p>
              ${deleteThreadBtn}
            </div>
            <p class="mt-2 text-gray-800 thread-content">${escapeHtml(data.teks)}</p>
            ${imagesHTML}
            <div class="action-buttons">
              <button class="like-btn action-btn ${isLiked ? 'text-red-500' : 'text-gray-500'}" onclick="likeThread('${id}', ${isLiked})">
                <i class="fas fa-heart ${isLiked ? 'text-red-500' : ''}"></i>
                <span>${likeCount}</span>
              </button>
              <button class="reply-btn action-btn text-gray-500" onclick="focusReply('${id}')">
                <i class="fas fa-comment"></i>
                <span id="reply-count-${id}">0</span>
              </button>
            </div>

            <div class="comments-header">
              <div class="comments-title">Komentar</div>
              <button class="comments-toggle-btn" data-thread="${id}" onclick="toggleComments('${id}')">
                <i class="fas fa-chevron-down toggle-icon collapsed" id="toggle-icon-${id}"></i>
                <span id="toggle-text-${id}">0 komentar</span>
              </button>
            </div>

            <div class="comments-section collapsed" id="comments-${id}">
              <div class="mt-3 space-y-3" id="replies-${id}"></div>

              <div class="reply-input-container mt-3">
                <div class="avatar" style="width:32px;height:32px;font-size:0.875rem; background-color: #9999ff;">
                  <span>${(currentProfile?.name?.charAt(0) || currentUser.email.charAt(0)).toUpperCase()}</span>
                </div>
                <input id="reply-${id}" type="text" placeholder="Tulis balasan..." class="reply-input">
                <button onclick="replyToThread('${id}')" class="send-reply-btn" id="send-reply-${id}" disabled>
                  <i class="fas fa-paper-plane"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      threadsDiv.appendChild(div);

      // Setup reply input event listener
      setTimeout(() => {
        const replyInput = div.querySelector(`#reply-${id}`);
        const sendReplyBtn = div.querySelector(`#send-reply-${id}`);
        
        if (replyInput && sendReplyBtn) {
          // Enable/disable send button based on input
          replyInput.addEventListener('input', () => {
            const hasText = replyInput.value.trim().length > 0;
            sendReplyBtn.disabled = !hasText;
          });
          
          // Enter key untuk balas
          replyInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              if (!sendReplyBtn.disabled) {
                window.replyToThread(id);
              }
            }
          });
        }
      }, 100);

      // Load replies (with cache)
      loadReplies(id);
    }

    // Load replies for a thread (with cache)
    async function loadReplies(threadId) {
      // Try to get from cache first
      const cachedReplies = await getRepliesFromCache(threadId);
      
      if (cachedReplies.length > 0) {
        // Render cached replies
        const repliesDiv = document.getElementById(`replies-${threadId}`);
        const replyCountSpan = document.getElementById(`reply-count-${threadId}`);
        const toggleText = document.getElementById(`toggle-text-${threadId}`);
        
        if (repliesDiv) {
          repliesDiv.innerHTML = "";
          cachedReplies.forEach((reply) => {
            repliesDiv.innerHTML += renderReply(reply, ['#9999ff','#ff9999','#99ff99','#ff99ff','#ffcc99','#ffff99'], threadId, reply.id);
          });
          
          if (replyCountSpan) replyCountSpan.textContent = cachedReplies.length;
          if (toggleText) toggleText.textContent = `${cachedReplies.length} komentar`;
          
          // Render LaTeX inside replies area
          renderMathInElement(repliesDiv, {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
            ]
          });
        }
        console.log(`Loaded ${cachedReplies.length} replies from cache for thread ${threadId}`);
      }
      
      // Then setup real-time listener
      const repliesRef = collection(db, "threads", threadId, "replies");
      const q = query(repliesRef, orderBy("createdAt", "asc"));
      
      onSnapshot(q, async (snap) => {
        const repliesDiv = document.getElementById(`replies-${threadId}`);
        const replyCountSpan = document.getElementById(`reply-count-${threadId}`);
        const toggleText = document.getElementById(`toggle-text-${threadId}`);
        if (!repliesDiv) return;
        
        const repliesToCache = [];
        let count = 0;
        
        repliesDiv.innerHTML = "";
        snap.forEach((rDoc) => {
          const rData = rDoc.data();
          repliesDiv.innerHTML += renderReply(rData, ['#9999ff','#ff9999','#99ff99','#ff99ff','#ffcc99','#ffff99'], threadId, rDoc.id);
          count++;
          
          // Prepare for caching
          repliesToCache.push({
            id: rDoc.id,
            ...rData,
            threadId: threadId,
            createdAt: rData.createdAt?.toDate?.()?.getTime() || Date.now()
          });
        });
        
        if (replyCountSpan) replyCountSpan.textContent = count;
        if (toggleText) toggleText.textContent = `${count} komentar`;
        
        // Save to cache
        if (repliesToCache.length > 0) {
          await saveRepliesToCache(threadId, repliesToCache);
        }
        
        // Render LaTeX inside replies area
        renderMathInElement(repliesDiv, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
          ]
        });
      }, (err) => {
        console.error("replies snapshot error:", err);
      });
    }

    // Render single reply; include delete button only if owner
    function renderReply(r, colors, threadId, replyId) {
      const replyColorIndex = Math.abs(hashCode(r.name || r.email || "")) % colors.length;
      const replyAvatarColor = colors[replyColorIndex];
      const replyInitial = (r.name || r.email || "").charAt(0).toUpperCase();
      const canDelete = r.uid === currentUser.uid;
      const deleteBtn = canDelete
        ? `<button onclick="deleteReply('${threadId}','${replyId}')" title="Hapus balasan" class="ml-2 text-red-500 hover:text-red-700 text-xs"><i class="fas fa-trash"></i></button>`
        : "";

      return `
        <div class="reply-item">
          <div class="flex items-start gap-2">
            <div class="avatar" style="width:32px;height:32px;font-size:0.875rem; background-color: ${replyAvatarColor};">
              <span>${replyInitial}</span>
            </div>
            <div class="bg-gray-50 p-3 rounded-lg flex-1 min-w-0">
              <div class="flex items-center gap-1">
                <p class="text-xs font-medium text-gray-900 truncate">${escapeHtml(r.name || r.email)}</p>
                <span class="text-xs text-gray-500">â€¢</span>
                <p class="text-xs text-gray-500 whitespace-nowrap">${formatDate(r.createdAt?.toDate?.() || r.createdAt)}</p>
                ${deleteBtn}
              </div>
              <p class="mt-1 text-sm text-gray-800 break-words">${escapeHtml(r.teks)}</p>
            </div>
          </div>
        </div>
      `;
    }

    // Toggle show/hide comments
    window.toggleComments = function(threadId) {
      const commentsSection = document.getElementById(`comments-${threadId}`);
      const toggleIcon = document.getElementById(`toggle-icon-${threadId}`);
      const toggleText = document.getElementById(`toggle-text-${threadId}`);
      const replyCount = document.getElementById(`reply-count-${threadId}`).textContent;
      
      if (commentsSection.classList.contains('collapsed')) {
        // Expand comments
        commentsSection.classList.remove('collapsed');
        toggleIcon.classList.remove('collapsed');
        toggleText.textContent = 'Sembunyikan';
      } else {
        // Collapse comments
        commentsSection.classList.add('collapsed');
        toggleIcon.classList.add('collapsed');
        toggleText.textContent = `${replyCount} komentar`;
      }
    };

    // Balas thread (subkoleksi)
    window.replyToThread = async function(id) {
      const input = document.getElementById(`reply-${id}`);
      if (!input || !input.value.trim()) return;
      
      try {
        const repliesRef = collection(db, "threads", id, "replies");
        await addDoc(repliesRef, {
          uid: currentUser.uid,
          email: currentUser.email,
          name: currentProfile?.name || currentUser.email,
          teks: input.value,
          createdAt: serverTimestamp()
        });
        input.value = "";
        
        // Disable send button after sending
        const sendReplyBtn = document.getElementById(`send-reply-${id}`);
        if (sendReplyBtn) {
          sendReplyBtn.disabled = true;
        }
      } catch (err) {
        console.error("add reply error:", err);
        alert("Gagal menambah balasan: " + err.message);
      }
    };

    // Delete reply (only works if rules allow; UI already ensures only owner sees button)
    window.deleteReply = async function(threadId, replyId) {
      if (!confirm("Yakin ingin menghapus balasan ini?")) return;
      try {
        const ref = doc(db, "threads", threadId, "replies", replyId);
        await deleteDoc(ref);
        
        // Clear cache for this reply
        if (dbCache) {
          const transaction = dbCache.transaction([REPLIES_STORE], 'readwrite');
          const store = transaction.objectStore(REPLIES_STORE);
          store.delete(replyId);
        }
      } catch (err) {
        console.error("delete reply error:", err);
        alert("Gagal menghapus balasan: " + err.message);
      }
    };

    // Delete thread + its replies (batch delete). Only owner can delete (rules enforced server-side).
    window.deleteThread = async function(threadId) {
      if (!confirm("Yakin ingin menghapus thread ini beserta semua balasannya?")) return;
      try {
        // batch delete replies then thread
        const repliesRef = collection(db, "threads", threadId, "replies");
        const repliesSnap = await getDocs(repliesRef);
        const batch = writeBatch(db);
        repliesSnap.forEach((rDoc) => {
          batch.delete(rDoc.ref);
        });
        // delete thread doc
        const threadRef = doc(db, "threads", threadId);
        batch.delete(threadRef);
        await batch.commit();
        
        // Clear cache for this thread and its replies
        if (dbCache) {
          const transaction = dbCache.transaction([THREADS_STORE, REPLIES_STORE], 'readwrite');
          const threadsStore = transaction.objectStore(THREADS_STORE);
          const repliesStore = transaction.objectStore(REPLIES_STORE);
          
          threadsStore.delete(threadId);
          
          // Delete all replies for this thread
          const index = repliesStore.index('threadId');
          const request = index.getAllKeys(threadId);
          request.onsuccess = () => {
            request.result.forEach(key => {
              repliesStore.delete(key);
            });
          };
        }
        
        // Reload threads after deletion
        await loadThreads();
      } catch (err) {
        console.error("delete thread error:", err);
        alert("Gagal menghapus thread: " + err.message);
      }
    };

    // Like / Unlike (ke sederhana)
    window.likeThread = async function(id, isCurrentlyLiked) {
      try {
        const ref = doc(db, "threads", id);
        const snap = await getDoc(ref);
        const data = snap.data() || {};
        const currentLikes = data.likes || 0;
        if (isCurrentlyLiked) {
          await updateDoc(ref, { likes: Math.max(0, currentLikes - 1), likedBy: arrayRemove(currentUser.uid) });
        } else {
          await updateDoc(ref, { likes: currentLikes + 1, likedBy: arrayUnion(currentUser.uid) });
        }
        
        // Update cache
        if (dbCache) {
          const transaction = dbCache.transaction([THREADS_STORE], 'readwrite');
          const store = transaction.objectStore(THREADS_STORE);
          const request = store.get(id);
          request.onsuccess = () => {
            const thread = request.result;
            if (thread) {
              thread.likes = isCurrentlyLiked ? Math.max(0, currentLikes - 1) : currentLikes + 1;
              thread.likedBy = isCurrentlyLiked 
                ? (thread.likedBy || []).filter(uid => uid !== currentUser.uid)
                : [...(thread.likedBy || []), currentUser.uid];
              thread.cachedAt = Date.now();
              store.put(thread);
            }
          };
        }
      } catch (err) {
        console.error("like error:", err);
      }
    };

    window.focusReply = function(id) {
      const el = document.getElementById(`reply-${id}`);
      if (el) el.focus();
    };
    
    // Open image modal
    window.openImageModal = openImageModal;
    
    // Open AI feature
    window.openAIFeature = function(feature) {
      alert(`Membuka fitur AI: ${feature}`);
      closeSidebarFunc();
    };

    // Helpers
    function hashCode(str) { let hash = 0; for (let i=0;i<str.length;i++){ hash = str.charCodeAt(i) + ((hash<<5)-hash); } return hash; }
    function formatDate(date) {
      if (!date) return 'baru saja';
      const now = new Date(), diff = Math.floor((now - date)/1000);
      if (diff<60) return 'beberapa detik lalu';
      if (diff<3600) return `${Math.floor(diff/60)} menit lalu`;
      if (diff<86400) return `${Math.floor(diff/3600)} jam lalu`;
      if (diff<2592000) return `${Math.floor(diff/86400)} hari lalu`;
      return date.toLocaleDateString('id-ID',{year:'numeric',month:'short',day:'numeric'});
    }

    // basic HTML escape to avoid accidental HTML injection
    function escapeHtml(s) {
      if (!s && s !== 0) return "";
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

  </script>
</body>
  </html>
